#pragma config(Sensor, in1,    LeftPoteniometer, sensorPotentiometer)
#pragma config(Sensor, in3,    LightSensor,    sensorReflection)
#pragma config(Sensor, in8,    RightPoteniometer, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, FrontSonar,     sensorSONAR_inch)
#pragma config(Motor,  port1,           RightSideBack, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port2,           RightSideFront, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           RightArm,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           RightIntake,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           LeftIntake,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           LeftArm,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port9,           LeftSideFront, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          LeftSideBack,  tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

////////////////////////////////////////////////////////////
int wheels_deadband = 15;
int fullspeed       = 127;
int halfspeed       = 63;
int halfsecond      = 500;
int onesecond       = 1000;
int twoseconds      = 2000;
int threeseconds    = 3000;
int fourseconds     = 4000;
int fiveseconds     = 5000;
int tenseconds      = 10000;
int stopped         = 0;
int pressed         = 1;
int robot_rotate    = 0, robot_fwd_rev = 0, robot_translate = 0;
int RightEncoderCounts = SensorValue[RightEncoder];
int LeftEncoderCounts = SensorValue[LeftEncoder];
int oneturn = 90;
int LeftPoteniometerLimit_32 = 1768, RightPoteniometerLimit_32    = 2925;
int LeftPoteniometerLimit_20 = 2240, RightPoteniometerLimit_20 = 2150;
int LeftPoteniometerLimit_10 = 2835, RightPoteniometerLimit_10  = 1600;
int LeftPoteniometerLimit_0  = 3310, RightPoteniometerLimit_0    = 1330;
int LeftPoteniometerDesired  = 0, RightPoteniometerDesired    = 0;
int armdeadband = 200;
////////////////////////////////////////////////////////////


//Define tasks
void stopWheels()
{
    motor[LeftSideFront]  = stopped;
    motor[LeftSideBack]   = stopped;
    motor[RightSideFront] = stopped;
    motor[RightSideBack]  = stopped;
}

void stopArms()
{
    motor[RightArm] = stopped;
    motor[LeftArm]  = stopped;
}

void moveForward(int speed = fullspeed)
{
    motor[LeftSideFront]  = speed;
    motor[LeftSideBack]   = speed;
    motor[RightSideFront] = speed;
    motor[RightSideBack]  = speed;
}

void moveForwardTimed(int t, int speed)
{
    moveForward(speed);
    wait1Msec(t);
    stopWheels();
}

void moveBack(int speed)
{
    motor[LeftSideFront]  = speed;
    motor[LeftSideBack]   = speed;
    motor[RightSideFront] = speed;
    motor[RightSideBack]  = speed;
}

void moveBackTimed(int t, int speed)
{
    moveBack(speed);
    wait1Msec(t);
    stopWheels();
}

void moveLeft(int speed)
{
    motor[LeftSideFront]  = -speed;
    motor[LeftSideBack]   = speed;
    motor[RightSideFront] = speed;
    motor[RightSideBack]  = -speed;
}

void moveLeftTimed(int t, int speed)
{
    moveLeft(speed);
    wait1Msec(t);
    stopWheels();
}

void moveRight(int speed)
{
    motor[LeftSideFront]  = -speed;
    motor[LeftSideBack]   = speed;
    motor[RightSideFront] = speed;
    motor[RightSideBack]  = -speed;
}

void moveRightTimed(int t, int speed)
{
    moveRight(speed);
    wait1Msec(t);
    stopWheels();
}

void turnRight()
{
    motor[LeftSideFront]  = fullspeed;
    motor[LeftSideBack]   = fullspeed;
    motor[RightSideFront] = -fullspeed;
    motor[RightSideBack]  = -fullspeed;
}

void turnRightTimed(int t)
{
    turnRight();
    wait1Msec(t);
    stopWheels();
}

void turnLeft()
{
    motor[LeftSideFront]  = -fullspeed;
    motor[LeftSideBack]   = -fullspeed;
    motor[RightSideFront] = fullspeed;
    motor[RightSideBack]  = fullspeed;
}

void turnLeftTimed(int t)
{
    turnLeft();
    wait1Msec(t);
    stopWheels();
}

void raiseArms()
{
    motor[LeftArm]  = fullspeed;
    motor[RightArm] = fullspeed;
}

void raiseArmsTimed(int t)
{
    raiseArms();
    wait1Msec(t);
    stopArms();
}

void lowerArms()
{
    motor[LeftArm]  = -fullspeed;
    motor[RightArm] = -fullspeed;
}

void lowerArmsTimed(int t)
{
    lowerArms();
    wait1Msec(t);
    stopArms();
}

void IntakeSystemIn()
{
    motor[RightIntake] = fullspeed;
    motor[LeftIntake] = fullspeed;
}

void IntakeSystemOut()
{
    motor[RightIntake] = -fullspeed;
    motor[LeftIntake] = -fullspeed;
}

void IntakeSystemStop()
{
    motor[RightIntake] = stopped;
    motor[LeftIntake] = stopped;
}

void IntakeSystemInTimed(int t)
{
    IntakeSystemIn();
    wait1Msec(t);
    IntakeSystemStop();
}

void IntakeSystemOutTimed(int t)
{
    IntakeSystemOut();
    wait1Msec(t);
    IntakeSystemStop();
}

void moveForwardDistance(int dist)
{
	  //Assuming that "dist" is going to be figured out later
    //"dist" would be the encoder counts until it stops moving; we can make "onefoot" variables etc. later.
	  while(RightEncoderCounts <= dist)
	  {
	  	moveForward(fullspeed);
	  }
	  stopWheels();
}

void moveBackDistance(int dist)
{
	  //Assuming that "dist" is going to be figured out later
    //"dist" would be the encoder counts until it stops moving; we can make "onefoot" variables etc. later.
	  while(RightEncoderCounts <= dist)
	  {
	  	moveBack(fullspeed);
	  }
	  stopWheels();
}

void turnRightAmount(int amount)
{
	  //Assuming that "amount" is going to be figured out later
    //"amount" would be the left encoder counts until it stops moving
	  while(LeftEncoderCounts <= amount)
	  {
	  	turnRight();
	  }
}

void turnLeftAmount(int amount)
{
	  //Assuming that "amount" is going to be figured out later
    //"amount" would be the right encoder counts until it stops moving
	  while(RightEncoderCounts <= amount)
	  {
	  	turnLeft();
	  }
}

void moveStraightForDist(float rotations = 1.0)
{
  SensorValue[RightEncoder] = 0;
  SensorValue[LeftEncoder]  = 0;

  while(SensorValue[RightEncoder] < (abs(rotations) * 360))
  {
		if(SensorValue[RightEncoder] == SensorValue[LeftEncoder]) // If rightEncoder has counted the same amount as leftEncoder:
		{
			// Move Forward
			motor[LeftSideFront]  = 127;
			motor[LeftSideBack]   = 127;
		  motor[RightSideFront] = 127;
		  motor[RightSideBack]  = 127;
		}
		else if(SensorValue[RightEncoder] > SensorValue[LeftEncoder])	// If rightEncoder has counted more encoder counts
		{
			// Turn slightly right
			motor[LeftSideFront]  = 127;
			motor[LeftSideBack]   = 127;
		  motor[RightSideFront] = 100;
		  motor[RightSideBack]  = 100;
		}
		else	// Only runs if leftEncoder has counted more encoder counts
		{
			// Turn slightly left
			motor[LeftSideFront]  = 100;
			motor[LeftSideBack]   = 100;
		  motor[RightSideFront] = 127;
		  motor[RightSideBack]  = 127;
		}
		wait1Msec(1);
  }
}
void ArmsRaiseToValue(int value)
{
	untilPotentiometerGreaterThan(value, in1);
	{
		raiseArms();
	}
}

void moveLeftDist(int tiles = 1)
{
	LeftEncoderCounts  = 0;
  RightEncoderCounts = 0;
  
	while(RightEncoderCounts <= (tiles*172))
  {
  	moveLeft(fullspeed);
  }
  stopWheels();
  	
  LeftEncoderCounts  = 0;
  RightEncoderCounts = 0;
}

void moveBackDist(float tiles = 1)
{
	LeftEncoderCounts  = 0;
  RightEncoderCounts = 0;
	while(abs(RightEncoderCounts) <= (tiles*172))
  {
  		moveBack(fullspeed);
  }
  stopWheels();
  LeftEncoderCounts  = 0;
  RightEncoderCounts = 0;
}

void moveForwardDist(float tiles = 1)
{
	LeftEncoderCounts  = 0;
  RightEncoderCounts = 0;
	while(abs(RightEncoderCounts) <= (tiles*172))
  {
  		moveForward(fullspeed);
  }
  stopWheels();
  LeftEncoderCounts  = 0;
  RightEncoderCounts = 0;
}

void moveRightDist(int tiles = 1)
{
	LeftEncoderCounts  = 0;
  RightEncoderCounts = 0;
  
	while(LeftEncoderCounts <= (tiles*172))
  {
  	moveRight(fullspeed);
  }
  stopWheels();
  	
  LeftEncoderCounts  = 0;
  RightEncoderCounts = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                              //
//                          Pre-Autonomous Functions                                            //
//                                                                                              //
// You may want to perform some actions before the competition starts. Do them in the           //
// following function.                                                                          //
//                                                                                              //
//////////////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
SensorValue[RightEncoder] = 0;
SensorValue[LeftEncoder]  = 0;
RightEncoderCounts        = 0;
LeftEncoderCounts         = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                          //                                       
//                                 Autonomous Task                                          //
//                                                                                          //    
// This task is used to control your robot during the autonomous phase of a VEX Competition.//
// You must modify the code to add your own robot specific commands here.                   //
//                                                                                          //
////////////////////////////////////////////////////////////////////////////////////////////// 

task autonomous()
{
    bool inRedDeadZone       = false;
    bool inRedMidZone        = false;
    bool inBlueDeadZone      = false;
    bool inBlueMidZone       = false;
    bool isindeadzone        = false;
    bool isred               = false;
    bool isblue              = false;
    bool isinmiddlezone      = false;
//Finding the position and setting it to true
    
 /*
    if (SensorValue[FrontSonar] > 3 && SensorValue[FrontSonar] < 12)
    {
        isindeadzone = true;
    }
    else if (SensorValue[FrontSonar] > 12) 
    {
            isinmiddlezone = true;
    }
    if (SensorValue[LightSensor] == 1)
    {
        isblue = true;
    }
    else if (SensorValue[LightSensor] == 0)
    {
        isred = true;
    }
    */


    /*
    if (isindeadzone && isred)
    {
        inRedDeadZone = true;
    }
    else if (isindeadzone && isblue)
    {
        inBlueDeadZone = true;
    }
    else if (isinmiddlezone && isred)
    {
        inRedMidZone = true;
    }
    else if (isinmiddlezone && isblue)
    {
        inBlueMidZone = true;
    }
    */

  if (inRedDeadZone)
  {
  	//One wheel rotation is 12.56 inches
    //This means that 7.17 encoder counts is 1 inch.
    //Each tile on the field is 2 feet, or 24 inches.
    //This means that 1 tile is about 172 encoder counts.
    //Also assuming that the encoders are on the back wheels.
    //ALSO assuming that the robot is facing the bar
    ///////////////////////////////////////////////////
    
    //This will move the robot forward for 1 tile length.
  	moveForwardDist(1);
  	//This will move the robot left until it goes a full tile
  	moveLeftDist(1);
  	//This will move the robot backward until it successfully moves the beach ball into the mid zone.
  	moveBackDist(1.2);
  	//This will move the robot forward until it returns to its original position
  	moveForwardDist(1.2);
  	//This will move the robot left until it goes a full tile
  	moveLeftDist(1);
  	//This will move the robot backward until it successfully moves the beach ball into the mid zone.
  	moveBackDist(2.5);
  } //End of red deadzone code
  else if (inRedMidZone)
  {
    //Assuming that the robot is facing the goal zone
    raiseArmsTimed(fourseconds);
    moveForwardDist(1.2);
    moveBackDist(1.1);
    moveRightDist(1.1);
    moveForwardDist(1.2);
    moveBackDist(1.1);
    lowerArmsTimed(threeseconds);
  }
  else if (inBlueMidZone)
  {
  	//Assuming that the robot is facing the goal zone
    raiseArmsTimed(fourseconds);
    moveForwardDist(1.2);
    moveBackDist(1.1);
    moveLeftDist(1.1);
    moveForwardDist(1.2);
    moveBackDist(1.1);
    lowerArmsTimed(threeseconds);
  }
  else if (inBlueDeadZone)
  {
  	//Assuming that the robot is facing the bar
  	moveForwardDist(1);
  	moveRightDist(1);
  	moveBackDist(1.2);
  	moveForwardDist(1.2);
  	moveRightDist(1);
  	moveBackDist(2.5);
  }
  else
  {
    //THIS IS ERROR AUTONOMOUS.  THIS ONLY HAPPENS IF THE ROBOT ISN'T FACING THE RIGHT WAY OR CAN'T DETECT WHERE IT IS
    /*
    moveForwardTimed(onesecond, fullspeed);
    moveBackTimed(onesecond,fullspeed);
    moveForwardTimed(onesecond, fullspeed);
    moveBackTimed(onesecond,fullspeed);
    moveForwardTimed(onesecond, fullspeed);
    moveBackTimed(onesecond,fullspeed);
    moveForwardTimed(onesecond, fullspeed);
    moveBackTimed(onesecond,fullspeed);
    moveForwardTimed(onesecond, fullspeed);
    moveBackTimed(onesecond,fullspeed);
    moveForwardTimed(onesecond, fullspeed);
    moveBackTimed(onesecond,fullspeed);
    moveForwardTimed(onesecond, fullspeed);
    moveBackTimed(onesecond,fullspeed);
    */
  }
}//END AUTONOMOUS




//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////User Control Task///////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
// This task is used to control your robot during the user control phase of a VEX Competition.////////
// You must modify the code to add your own robot specific commands here./////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////




task usercontrol()
{
  // Loop Forever
  while (true)
  {
      if (vexRT[Btn8D] == pressed)
      {
         ArmsRaiseToValue(3300);
      }
      else if (vexRT[Btn8U] == pressed)
      {
         ArmsRaiseToValue(1768);		
     	}
      else if (vexRT[Btn8R] == pressed)
      {
         ArmsRaiseToValue(2240);	
      }
      else if(vexRT[Btn8L] == pressed)
      {
         ArmsRaiseToValue(2835);	 
     	}
     	else
     	{
     		stopArms();
     	}
    //These are the arms controls (Call of Duty trigger buttons)
    if(vexRT[Btn6U] == pressed)
    {
        raiseArms();
    }
    else if(vexRT[Btn6D] == pressed)
    {
        lowerArms();
    }
    else 
    {
        stopArms();
    }
    //These are the intake controls (Call of Duty trigger buttons LEFT)
    if(vexRT[Btn5U] == pressed)
    {
    	IntakeSystemIn();
    }
    else if(vexRT[Btn5D] == pressed)
    {
    	IntakeSystemOut();
    }
    else
    {
    	IntakeSystemStop();
    }
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  
		if(abs(vexRT[Ch3]) > wheels_deadband)
      robot_fwd_rev = vexRT[Ch3];
    else
      robot_fwd_rev = 0;
    //Create "deadzone" for robot_translate/Ch4
    if(abs(vexRT[Ch4]) > wheels_deadband)
      robot_translate = vexRT[Ch4];
    else
      robot_translate = 0;
    //Create "deadzone" for robot_rotate/Ch1
    if(abs(vexRT[Ch1]) > wheels_deadband)
      robot_rotate = vexRT[Ch1];
    else
      robot_rotate = 0;
    //Remote Control Commands
    motor[LeftSideFront]  = robot_fwd_rev + robot_translate + robot_rotate;
    motor[LeftSideBack]   = robot_fwd_rev - robot_translate + robot_rotate;
    motor[RightSideFront] = robot_fwd_rev - robot_translate - robot_rotate;
    motor[RightSideBack]  = robot_fwd_rev + robot_translate - robot_rotate;
  }//End of infinite while loop
}//End user control
